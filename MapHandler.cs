using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Drawing;

namespace TFIServer
{
    enum ZoneIds
    {
        WaterDeep,
        Boulders,
        Stairs,
        Threshold,
        ClosedArea              // zone_layer array should be 5 elements.
    }

    enum ZoneBits
    {
        // Bitfield usage.
        None            = 0,
        WaterDeep       = 1 << ZoneIds.WaterDeep,
        Boulders        = 1 << ZoneIds.Boulders,
        Stairs          = 1 << ZoneIds.Stairs,
        Threshold       = 1 << ZoneIds.Threshold,
        ClosedArea      = 1 << ZoneIds.ClosedArea
    }

    static class ZoneExtensions
    {
        public static bool Contains(this ZoneBits zones, ZoneBits to_test)
        {
            return (zones & to_test) == to_test;
        }

        public static ZoneBits ToBit(this ZoneIds zid)
        {
            return (ZoneBits)(1 << (int)zid);
        }

        public static int Index(this ZoneIds zid)
        {
            return (int)zid;
        }
    }

    struct MapCell
    {
        public short tile;
        public short rle;
    }

    class MapHandler
    {

        public readonly int mapVersion = 2;

        public int Layers { get => map_.GetLength(0); }
        public int Row_count { get => map_.GetLength(1); }
        public int Column_count { get => map_.GetLength(2); }
        public int Scale { get => scale_;  }
        public Size Pixels_size { get => new Size(pixels_wide_, pixels_height_); }

        // The conversion from Tiled units to pixels.
        private int scale_;

        // The map is [layer][rows][columns]. The |columns| is the count
        // of elements in the x coordinate, in other words the size of each row.
        private MapCell[,,] map_;

        // Zones is one list of polygons per each ZoneId per object layer
        // so a poligon is zones[layer][zone][poligon]. 
        private readonly List<List<List<Point>>[]> zones_
            = new List<List<List<Point>>[]>();

        private List<Rectangle> player_spawn_;

        private int pixels_wide_;
        private int pixels_height_;

        // The scale is used to scale all the loaded properties
        // that use distances. Tiled uses floating point pixels.

        public IEnumerable<Rectangle> GetPlayerSpawns()
        {
            foreach (var spawn in player_spawn_)
            {
                yield return new Rectangle(
                    spawn.X, spawn.Y,
                    spawn.Width, spawn.Height);
            }
        }

        public bool SendMap(int toClient)
        {
            for (int layer = 0; layer < Layers; layer++)
            {
                for (int iy = 0; iy < Row_count; iy++)
                {
                    var real_row = Row_count - iy - 1;
                    ServerSend.MapLayerRow(
                        toClient, layer, real_row, Column_count, GetRowIter(layer, iy));
                }
            }

            return true;
        }

        // Maps are JSON files generated by Tiled map editor (https://github.com/mapeditor/tiled).
        // The current good maps are in the "maps" directory for source control purposes.
        public void LoadMapJSON(string path_map)
        {
            using (var reader = new System.IO.StreamReader(path_map))
            {
                var root = JsonDocument.Parse(reader.BaseStream).RootElement;
                
                if (root.GetProperty("type").GetString() != "map")
                {
                    throw new Exception($"Map error: type is a not map");
                }
                
                var column_count = root.GetProperty("width").GetInt32();
                var row_count = root.GetProperty("height").GetInt32();
                var layers = root.GetProperty("layers");
                var layer_count = layers.GetArrayLength();

                var tile_width = root.GetProperty("tilewidth").GetInt32();
                var tile_height = root.GetProperty("tileheight").GetInt32();

                if ((tile_height != tile_width) || (tile_width < 5) || (tile_height < 5))
                {
                    throw new Exception($"Map error: unsuported scale");
                }

                scale_ = tile_width;
                pixels_wide_ = tile_width * column_count;
                pixels_height_ = tile_height * row_count;

                if (root.GetProperty("compressionlevel").GetInt32() != -1)
                {
                    // We don't support any compression.
                    throw new Exception($"Map error: unsupported compression");
                }

                // Currently we only support one tileset.
                var tilesets = root.GetProperty("tilesets");
                if (tilesets.GetArrayLength() != 1)
                {
                    throw new Exception($"Map error: too many tilesets");
                }

                var firstgid = tilesets[0].GetProperty("firstgid").GetInt32();
                if (firstgid != 1)
                {
                    // Client-side we expect 0 to mean "no title" and the first
                    // title to be 1.
                    throw new Exception($"Map error: firstgid is {firstgid}");
                }

                // Process object layers here.
                int map_objects = 0;

                player_spawn_ = new List<Rectangle>();

                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "objectgroup")
                    {
                        continue;
                    }

                    var zone_layer = new List<List<Point>>[5];

                    var objects = layer.GetProperty("objects");
                    foreach (var obj in objects.EnumerateArray())
                    {
                        int ix = -1;
                        map_objects++;

                        switch (obj.GetProperty("name").GetString())
                        {
                            case "spawn player":
                                player_spawn_.Add(RectFromJson(obj));
                                continue;

                            case "water deep":
                                ix = ZoneIds.WaterDeep.Index();
                                break;

                            case "boulder":
                                ix = ZoneIds.Boulders.Index();
                                break;

                            case "stairs":
                                ix = ZoneIds.Stairs.Index();
                                break;

                            case "threshold":
                                ix = ZoneIds.Threshold.Index();
                                break;

                            case "closed area":
                                ix = ZoneIds.ClosedArea.Index();
                                break;

                            default:
                                Console.WriteLine(
                                    $"unknown entity {obj.GetProperty("name").GetString()}");
                                continue;
                        }

                        if (zone_layer[ix] == null)
                        {
                            zone_layer[ix] = new List<List<Point>>();
                        }
                        zone_layer[ix].Add(PolygonFromJson(obj));

                    }

                    zones_.Add(zone_layer);
                }

                layer_count -= zones_.Count;
                map_ = new MapCell[layer_count, row_count, column_count];

                // Only process tile layers on this loop.
                int lyr = 0;
                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "tilelayer")
                    {
                        continue;
                    }

                    var data = layer.GetProperty("data");
                    int col = 0;
                    foreach (var cell in data.EnumerateArray())
                    {
                        var id = cell.GetInt16();
                        if (id == 0)
                        {
                            col++;
                            continue;
                        }

                        map_[lyr, col / row_count, col % column_count].tile = id;
                        col++;
                    }
                    lyr++;
                }

                RLECodec.EncodeInPlace(map_);

                Console.WriteLine($"loaded map [{path_map}]");
                Console.WriteLine($"tiles: {layer_count} x {row_count} x {column_count}");
                Console.WriteLine($"zones: {zones_.Count} x {6} count: {map_objects}");
            }
        }

        private static float GetJSonFloat(JsonElement elem, ReadOnlySpan<char> name)
        {
            return (float)elem.GetProperty(name).GetDouble();
        }

        private Rectangle RectFromJson(JsonElement obj)
        {
            var point = PointFromJson(obj);
            var size = SizeFromJson(obj);
            return new Rectangle(point, size);
        }

        private List<Point> PolygonFromJson(JsonElement obj)
        {
            var origin = PointFromJson(obj);

            var poly = new List<Point>();
            var array = obj.GetProperty("polygon");
            foreach(var point in array.EnumerateArray())
            {
                var rel_pt = RelPointFromJson(point);
                poly.Add(new Point(rel_pt.X + origin.X, rel_pt.Y + origin.Y));
            }

            return poly;
        }

        private Point PointFromJson(JsonElement obj)
        {
            var x = (int)GetJSonFloat(obj, "x");
            var y = pixels_height_ - (int)GetJSonFloat(obj, "y");
            return new Point(x, y);
        }

        private Point RelPointFromJson(JsonElement obj)
        {
            var x = (int)GetJSonFloat(obj, "x");
            var y = -(int)GetJSonFloat(obj, "y");
            return new Point(x, y);
        }

        private Size SizeFromJson(JsonElement obj)
        {
            var w = (int)GetJSonFloat(obj, "width");
            var h = (int)GetJSonFloat(obj, "height");
            return new Size(w, h);
        }

   
        // The row iterator returns the row RLE encoded. Most of the
        // work was already done once by RLECodec when the map was
        // loaded.
        private IEnumerable<MapCell> GetRowIter(int layer, int row)
        {
            int ix = 0;
            do
            {
                var cell = map_[layer, row, ix];
                yield return cell;
                ix += cell.rle;
            } while (ix < Column_count);
        }

        // IsLeft(): tests if a point is Left|On|Right of an infinite line.
        //    Input:  three points l0, l1, and pt
        //    Return: > 0 for pt left of the line through l0 and l1
        //            == 0 for pt  on the line
        //            < 0 for pt  right of the line
        //
        // This is exactly the same computation for the 'signed' area of a
        // triangle if we consider the 3 points forming one. Which turns
        // out is the cross product of the two vectors and positive values
        // means the points are in clockwise order.
        private static int IsLeft(Point l0, Point l1, Point pt)
        {
            // This might be faster if we convert to Vector<int> SIMD magic.
            return ((l1.X - l0.X) * (pt.Y - l0.Y) - (pt.X - l0.X) * (l1.Y - l0.Y));
        }

        // WindingNumber(): winding number test for a point in a polygon.
        // from http://geomalgorithms.com/a03-_inclusion.html
        //      Input:   point = a point,
        //               poly[] = vertex points of a polygon V[n+1] with V[n]=V[0].
        //      Return:  wn = the winding number (== 0 only when point is outside)
        private static int WindingNumber(Point point, List<Point> poly)
        {
            int wn = 0;    // the  winding number counter.

            // loop through all edges of the polygon
            for (int ix = 0; ix < poly.Count; ix++)
            {   // edge from poly[i] to  poly[i+1]
                var next = (ix + 1) % poly.Count;
                if (poly[ix].Y <= point.Y)
                {
                    if (poly[next].Y > point.Y)
                    {   // an upward crossing.
                        if (IsLeft(poly[ix], poly[next], point) > 0.0)
                        {
                            // point left of edge and have a valid up intersect
                            ++wn;            
                        }
                    }
                }
                else
                {   // y > point.y (no test needed)
                    if (poly[next].Y <= point.Y)
                    {   // a downward crossing.
                        if (IsLeft(poly[ix], poly[next], point) < 0.0)
                        {
                            // point right of edge and have a valid down intersect
                            --wn;
                        }
                    }
                }
            }
            return wn;
        }

        private static bool InsidePolygonZone(List<List<Point>> polygons, Point point)
        {
            if (polygons == null)
            {
                return false;
            }

            foreach (var poly in polygons)
            {
                if (WindingNumber(point, poly) != 0)
                {
                    return true;
                }
            }
            return false;
        }

        // Returns all the zones the point is inside of. It short circuits so
        // if only evaluates up to finding one single hit of each type. For poligons
        // we use the optimized winding number which is a bit more expensive but can
        // handle complex poligons.
        public ZoneBits GetZonesForPoint(Point point, int level)
        {
            ZoneBits zones = ZoneBits.None;

            if (level >= zones_.Count)
            {
                return zones;
            }

            foreach (var zid in (ZoneIds[]) Enum.GetValues(typeof(ZoneIds)))
            {
                var polygons = zones_[level][zid.Index()];
                if (InsidePolygonZone(polygons, point))
                {
                    zones |= zid.ToBit();
                }
            }

            return zones;
        }

        // Returns 0 to N for the stair for a given point
        // -1 if no stairs found for the point.
        public int GetStairLevelForPoint(Point point)
        {
 
            for (int level = 0; level != zones_.Count; level++)
            {
                var polygons = zones_[level][ZoneIds.Stairs.Index()];
                if (InsidePolygonZone(polygons, point))
                {
                    return level;
                }
            }

            return -1;
        }

    }
}
