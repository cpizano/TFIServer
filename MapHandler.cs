using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Drawing;
using System.Numerics;

namespace TFIServer
{
    enum ZoneIds
    {
        WaterDeep,
        Boulders,
        Stairs,
        Threshold,
        Keep              // zone_layer array should be 5 elements.
    }

    enum ZoneBits
    {
        // Bitfield usage.
        None            = 0,
        WaterDeep       = 1 << ZoneIds.WaterDeep,
        Boulders        = 1 << ZoneIds.Boulders,
        Stairs          = 1 << ZoneIds.Stairs,
        Threshold       = 1 << ZoneIds.Threshold,
        Keep            = 1 << ZoneIds.Keep
    }

    static class ZoneExtensions
    {
        public static bool Contains(this ZoneBits zones, ZoneBits to_test)
        {
            return (zones & to_test) == to_test;
        }

        public static ZoneBits ToBit(this ZoneIds zid)
        {
            return (ZoneBits)(1 << (int)zid);
        }

        public static int Index(this ZoneIds zid)
        {
            return (int)zid;
        }
    }

    class MapHandler
    {

        public readonly int mapVersion = 2;

        public int Layers { get => map_.GetLength(0); }
        public int Row_count { get => map_.GetLength(1); }
        public int Column_count { get => map_.GetLength(2); }
        public (int x, int y) Pixels_size { get => (pixels_wide_, pixels_height_); }

        // The conversion from Unity units to pixels.
        private readonly float scale_;

        // The map is [layer][rows][columns]. The |columns| is the count
        // of elements in the x coordinate, in other words the size of each row.
        private int[,,] map_;

        // Zones is one list of polygons per each ZoneId per object layer
        // so a poligon is zones[layer][zone][poligon]. 
        private readonly List<List<List<PointF>>[]> zones_ = new List<List<List<PointF>>[]>();

        private List<RectangleF> player_spawn_;

        private int pixels_wide_;
        private int pixels_height_;

        // The scale is used to scale all the loaded properties
        // that use distances. Tiled uses floating point pixels.
        public MapHandler(int scale_int)
        {
            scale_ = scale_int;
        }

        public IEnumerable<RectangleF> GetPlayerSpawns()
        {
            foreach (var spawn in player_spawn_)
            {
                yield return new RectangleF(spawn.X, spawn.Y, spawn.Width, spawn.Height);
            }
        }

        public bool SendMap(int toClient)
        {
            for (int layer = 0; layer < Layers; layer++)
            {
                for (int iy = 0; iy < Row_count; iy++)
                {
                    var real_row = Row_count - iy - 1;
                    ServerSend.MapLayerRow(
                        toClient, layer, real_row, Column_count, GetRowIter(layer, iy));
                }
            }

            return true;
        }

        // Maps are JSON files generated by Tiled map editor (https://github.com/mapeditor/tiled).
        // The current good maps are in the "maps" directory for source control purposes.
        public void LoadMapJSON(string path_map)
        {
            using (var reader = new System.IO.StreamReader(path_map))
            {
                var root = JsonDocument.Parse(reader.BaseStream).RootElement;
                
                if (root.GetProperty("type").GetString() != "map")
                {
                    throw new Exception($"Map error: type is a not map");
                }
                
                var column_count = root.GetProperty("width").GetInt32();
                var row_count = root.GetProperty("height").GetInt32();
                var layers = root.GetProperty("layers");
                var layer_count = layers.GetArrayLength();

                var tile_width = root.GetProperty("tilewidth").GetInt32();
                var tile_height = root.GetProperty("tileheight").GetInt32();

                pixels_wide_ = tile_width * column_count;
                pixels_height_ = tile_height * row_count;

                if (root.GetProperty("compressionlevel").GetInt32() != -1)
                {
                    // We don't support any compression.
                    throw new Exception($"Map error: unsupported compression");
                }

                // Currently we only support one tileset.
                var tilesets = root.GetProperty("tilesets");
                if (tilesets.GetArrayLength() != 1)
                {
                    throw new Exception($"Map error: too many tilesets");
                }

                var firstgid = tilesets[0].GetProperty("firstgid").GetInt32();
                if (firstgid != 1)
                {
                    // Client-side we expect 0 to mean "no title" and the first
                    // title to be 1.
                    throw new Exception($"Map error: firstgid is {firstgid}");
                }

                // Process object layers here.
                int map_objects = 0;

                player_spawn_ = new List<RectangleF>();

                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "objectgroup")
                    {
                        continue;
                    }

                    var zone_layer = new List<List<PointF>>[5];

                    var objects = layer.GetProperty("objects");
                    foreach (var obj in objects.EnumerateArray())
                    {
                        int ix = -1;
                        map_objects++;

                        switch (obj.GetProperty("name").GetString())
                        {
                            case "spawn player":
                                player_spawn_.Add(RectFromJson(obj));
                                continue;

                            case "water deep":
                                ix = ZoneIds.WaterDeep.Index();
                                break;

                            case "boulder":
                                ix = ZoneIds.Boulders.Index();
                                break;

                            case "stairs":
                                ix = ZoneIds.Stairs.Index();
                                break;

                            case "threshold":
                                ix = ZoneIds.Threshold.Index();
                                break;

                            case "keep":
                                ix = ZoneIds.Keep.Index();
                                break;

                            default:
                                Console.WriteLine(
                                    $"unknown entity {obj.GetProperty("name").GetString()}");
                                continue;
                        }

                        if (zone_layer[ix] == null)
                        {
                            zone_layer[ix] = new List<List<PointF>>();
                        }
                        zone_layer[ix].Add(PolygonFromJson(obj));

                    }

                    zones_.Add(zone_layer);
                }

                layer_count -= zones_.Count;
                map_ = new int[layer_count, row_count, column_count];

                // Only process tile layers on this loop.
                int lyr = 0;
                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "tilelayer")
                    {
                        continue;
                    }

                    var data = layer.GetProperty("data");
                    int col = 0;
                    foreach (var cell in data.EnumerateArray())
                    {
                        var id = cell.GetInt16();
                        if (id == 0)
                        {
                            col++;
                            continue;
                        }

                        map_[lyr, col / row_count, col % column_count] = id;
                        col++;
                    }
                    lyr++;
                }

                Console.WriteLine($"loaded map [{path_map}]");
                Console.WriteLine($"tiles: {layer_count} x {row_count} x {column_count}");
                Console.WriteLine($"zones: {zones_.Count} x {6} count: {map_objects}");
            }
        }

        private static float GetJSonFloat(JsonElement elem, ReadOnlySpan<char> name)
        {
            return (float)elem.GetProperty(name).GetDouble();
        }

        private RectangleF RectFromJson(JsonElement obj)
        {
            var point = PointFromJson(obj);
            var size = SizeFromJson(obj);
            return new RectangleF(point, size);
        }

        private List<PointF> PolygonFromJson(JsonElement obj)
        {
            var origin = PointFromJson(obj);

            List<PointF> poly = new List<PointF>();
            var array = obj.GetProperty("polygon");
            foreach(var point in array.EnumerateArray())
            {
                var rel_pt = RelPointFromJson(point);
                poly.Add(new PointF(rel_pt.X + origin.X, rel_pt.Y + origin.Y));
            }

            return poly;
        }

        private PointF PointFromJson(JsonElement obj)
        {
            var x = GetJSonFloat(obj, "x");
            var y = pixels_height_ - GetJSonFloat(obj, "y");
            return new PointF(x / scale_, y / scale_);
        }

        private PointF RelPointFromJson(JsonElement obj)
        {
            var x = GetJSonFloat(obj, "x");
            var y = -GetJSonFloat(obj, "y");
            return new PointF(x / scale_, y / scale_);
        }

        private SizeF SizeFromJson(JsonElement obj)
        {
            var w = GetJSonFloat(obj, "width");
            var h = GetJSonFloat(obj, "height");
            return new SizeF(w / scale_, h / scale_);
        }

        // So C# cannot return a reference to a row of a square array. Rather
        // than abandoning square arrays we can use a simple generator. Maybe
        // it is not as inneficient as it looks. 
        private IEnumerable<short> GetRowIter(int layer, int row)
        {
            for (var ix = 0; ix < Column_count; ix++)
            {
                yield return (short)map_[layer, row, ix];
            }
        }

        // IsLeft(): tests if a point is Left|On|Right of an infinite line.
        //    Input:  three points l0, l1, and pt
        //    Return: > 0 for pt left of the line through l0 and l1
        //            == 0 for pt  on the line
        //            < 0 for pt  right of the line
        //
        // This is exactly the same computation for the 'signed' area of a
        // triangle if we consider the 3 points forming one. Which turns
        // out is the cross product of the two vectors and positive values
        // means the points are in clockwise order.
        private static float IsLeft(PointF l0, PointF l1, PointF pt)
        {
            return ((l1.X - l0.X) * (pt.Y - l0.Y) - (pt.X - l0.X) * (l1.Y - l0.Y));
        }

        // WindingNumber(): winding number test for a point in a polygon.
        // from http://geomalgorithms.com/a03-_inclusion.html
        //      Input:   point = a point,
        //               poly[] = vertex points of a polygon V[n+1] with V[n]=V[0].
        //      Return:  wn = the winding number (== 0 only when point is outside)
        private static int WindingNumber(PointF point, List<PointF> poly)
        {
            int wn = 0;    // the  winding number counter.

            // loop through all edges of the polygon
            for (int ix = 0; ix < poly.Count; ix++)
            {   // edge from poly[i] to  poly[i+1]
                var next = (ix + 1) % poly.Count;
                if (poly[ix].Y <= point.Y)
                {
                    if (poly[next].Y > point.Y)
                    {   // an upward crossing.
                        if (IsLeft(poly[ix], poly[next], point) > 0.0)
                        {
                            // point left of edge and have a valid up intersect
                            ++wn;            
                        }
                    }
                }
                else
                {   // y > point.y (no test needed)
                    if (poly[next].Y <= point.Y)
                    {   // a downward crossing.
                        if (IsLeft(poly[ix], poly[next], point) < 0.0)
                        {
                            // point right of edge and have a valid down intersect
                            --wn;
                        }
                    }
                }
            }
            return wn;
        }

        private static bool InsidePolygonZone(List<List<PointF>> poligons, PointF point)
        {
            foreach (var poly in poligons)
            {
                if (WindingNumber(point, poly) != 0)
                {
                    return true;
                }
            }
            return false;
        }

        // Returns all the zones the point is inside of. It short circuits so
        // if only evaluates up to finding one single hit of each type. For poligons
        // we use the optimized winding number which is a bit more expensive but can
        // handle complex poligons.
        public ZoneBits GetZonesForPoint(PointF point, int level)
        {
            ZoneBits zones = ZoneBits.None;

            if (level >= zones_.Count)
            {
                return zones;
            }

            foreach (var zid in (ZoneIds[]) Enum.GetValues(typeof(ZoneIds)))
            {
                var polygons = zones_[level][zid.Index()];
                if (polygons == null)
                {
                    continue;
                }

                if (InsidePolygonZone(polygons, point))
                {
                    zones |= zid.ToBit();
                }
            }

            return zones;
        }
    }
}
