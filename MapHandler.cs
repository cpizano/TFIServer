using System;
using System.Collections.Generic;
using System.Text.Json;

namespace TFIServer
{
    class MapHandler
    {
        public readonly int mapVersion = 2;

        public int Layers { get => map.GetLength(0); }
        public int Row_count { get => map.GetLength(1); }
        public int Column_count { get => map.GetLength(2); }

        // The map is [layer][rows][columns]. The |columns| is the count
        // of elements in the x coordinate, in other words the size of each row.
        private int[,,] map;

        // Maps are JSON files generated by Tiled map editor (https://github.com/mapeditor/tiled).
        // The current good maps are in the "maps" directory for source control purposes, but the
        // maps that are actually used are expected to be in the output directory.
        public void LoadMapJSON(string path_map)
        {
            using (var reader = new System.IO.StreamReader(path_map))
            {
                var root = JsonDocument.Parse(reader.BaseStream).RootElement;
                var column_count = root.GetProperty("width").GetInt32();
                var row_count = root.GetProperty("height").GetInt32();
                var layers = root.GetProperty("layers");
                var layer_count = layers.GetArrayLength();

                if (root.GetProperty("compressionlevel").GetInt32() != -1)
                {
                    // We don't support any compression.
                    throw new Exception($"Map error: unsupported compression");
                }

                // Currently we only support one tileset.
                var tilesets = root.GetProperty("tilesets");
                if (tilesets.GetArrayLength() != 1)
                {
                    throw new Exception($"Map error: too many tilesets");
                }

                var firstgid = tilesets[0].GetProperty("firstgid").GetInt32();
                if (firstgid != 1)
                {
                    // Client-side we expect 0 to mean "no title" and the first
                    // title to be 1.
                    throw new Exception($"Map error: firstgid is {firstgid}");
                }

                map = new int[layer_count, row_count, column_count];

                int lyr = 0;
                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "tilelayer")
                    {
                        continue;
                    }

                    var data = layer.GetProperty("data");
                    int col = 0;
                    foreach (var cell in data.EnumerateArray())
                    {
                        map[lyr, col / row_count, col % column_count] = cell.GetInt16();
                        col++;
                    }
                    lyr++;
                }

                Console.WriteLine($"loaded map [{path_map}] {layer_count}x{row_count}x{column_count}");
            }
        }

        // So C# cannot return a reference to a row of a square array. Rather
        // than abandoning square arrays we can use a simple generator. Maybe
        // it is not as inneficient as it looks. 
        private IEnumerable<short> GetRowIter(int layer, int row)
        {
            for (var ix = 0; ix < Column_count; ix++)
            {
                yield return (short)map[layer, row, ix];
            }
        }

        public bool SendMap(int _toClient)
        {
            for (int layer = 0; layer < Layers; layer++)
            {
                for (int iy = 0; iy < Row_count; iy++)
                {
                    var real_row = Row_count - iy - 1;
                    ServerSend.MapLayerRow(
                        _toClient, layer, real_row, Column_count, GetRowIter(layer, iy));
                }
            }

            return true;
        }
    }
}
