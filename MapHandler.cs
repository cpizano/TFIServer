using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Drawing;
using System.Numerics;

namespace TFIServer
{
    class MapHandler
    {
        public readonly int mapVersion = 2;

        public int Layers { get => map.GetLength(0); }
        public int Row_count { get => map.GetLength(1); }
        public int Column_count { get => map.GetLength(2); }

        public (int x, int y) Pixels_size { get => (pixels_wide, pixels_height); }

        // The conversion from Unity units to pixels.
        private readonly float scale;

        // The map is [layer][rows][columns]. The |columns| is the count
        // of elements in the x coordinate, in other words the size of each row.
        private int[,,] map;
        private List<RectangleF> spawns;

        private int pixels_wide;
        private int pixels_height;

        public MapHandler(int scale_int)
        {
            scale = scale_int;
        }

        public IEnumerable<RectangleF> GetSpawns()
        {
            foreach (var spawn in spawns)
            {
                yield return new RectangleF(spawn.X, spawn.Y, spawn.Width, spawn.Height);
            }
        }

        // Maps are JSON files generated by Tiled map editor (https://github.com/mapeditor/tiled).
        // The current good maps are in the "maps" directory for source control purposes, but the
        // maps that are actually used are expected to be in the output directory.
        public void LoadMapJSON(string path_map)
        {
            using (var reader = new System.IO.StreamReader(path_map))
            {
                var root = JsonDocument.Parse(reader.BaseStream).RootElement;
                
                if (root.GetProperty("type").GetString() != "map")
                {
                    throw new Exception($"Map error: type is a not map");
                }
                
                var column_count = root.GetProperty("width").GetInt32();
                var row_count = root.GetProperty("height").GetInt32();
                var layers = root.GetProperty("layers");
                var layer_count = layers.GetArrayLength();

                var tile_width = root.GetProperty("tilewidth").GetInt32();
                var tile_height = root.GetProperty("tileheight").GetInt32();

                pixels_wide = tile_width * column_count;
                pixels_height = tile_height * row_count;

                if (root.GetProperty("compressionlevel").GetInt32() != -1)
                {
                    // We don't support any compression.
                    throw new Exception($"Map error: unsupported compression");
                }

                // Currently we only support one tileset.
                var tilesets = root.GetProperty("tilesets");
                if (tilesets.GetArrayLength() != 1)
                {
                    throw new Exception($"Map error: too many tilesets");
                }

                var firstgid = tilesets[0].GetProperty("firstgid").GetInt32();
                if (firstgid != 1)
                {
                    // Client-side we expect 0 to mean "no title" and the first
                    // title to be 1.
                    throw new Exception($"Map error: firstgid is {firstgid}");
                }

                // Process object layers here. We flatten them, that is we don't
                // care the ordering of their layers.
                int object_layers = 0;
                spawns = new List<RectangleF>();
                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "objectgroup")
                    {
                        continue;
                    }

                    var objects = layer.GetProperty("objects");
                    foreach (var obj in objects.EnumerateArray())
                    {
                        if (obj.GetProperty("name").GetString() == "spawn player")
                        {
                            var x = GetJSonFloat(obj, "x");
                            var y = pixels_height - GetJSonFloat(obj, "y");
                            var w = GetJSonFloat(obj, "width");
                            var h = GetJSonFloat(obj, "height");
                            spawns.Add(new RectangleF(x / scale, y / scale, w / scale, h / scale));
                        }
                    }

                    object_layers++;
                }

                layer_count -= object_layers;
                map = new int[layer_count, row_count, column_count];

                // Only process tile layers on this loop.
                int lyr = 0;
                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "tilelayer")
                    {
                        continue;
                    }

                    var data = layer.GetProperty("data");
                    int col = 0;
                    foreach (var cell in data.EnumerateArray())
                    {
                        var id = cell.GetInt16();
                        if (id == 0)
                        {
                            col++;
                            continue;
                        }

                        map[lyr, col / row_count, col % column_count] = id;
                        col++;
                    }
                    lyr++;
                }

                Console.WriteLine($"loaded map [{path_map}] {layer_count}x{row_count}x{column_count}");
            }
        }

        float GetJSonFloat(JsonElement elem, ReadOnlySpan<char> name)
        {
            return (float)elem.GetProperty(name).GetDouble();
        }

        // So C# cannot return a reference to a row of a square array. Rather
        // than abandoning square arrays we can use a simple generator. Maybe
        // it is not as inneficient as it looks. 
        private IEnumerable<short> GetRowIter(int layer, int row)
        {
            for (var ix = 0; ix < Column_count; ix++)
            {
                yield return (short)map[layer, row, ix];
            }
        }

        public bool SendMap(int _toClient)
        {
            for (int layer = 0; layer < Layers; layer++)
            {
                for (int iy = 0; iy < Row_count; iy++)
                {
                    var real_row = Row_count - iy - 1;
                    ServerSend.MapLayerRow(
                        _toClient, layer, real_row, Column_count, GetRowIter(layer, iy));
                }
            }

            return true;
        }
    }
}
