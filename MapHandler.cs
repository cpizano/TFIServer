using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Drawing;
using System.Numerics;

namespace TFIServer
{
    class MapHandler
    {
        enum Zones
        {
            WaterDeep,
            PlayerSpawn
        }

        public readonly int mapVersion = 2;

        public int Layers { get => map_.GetLength(0); }
        public int Row_count { get => map_.GetLength(1); }
        public int Column_count { get => map_.GetLength(2); }
        public (int x, int y) Pixels_size { get => (pixels_wide_, pixels_height_); }

        // The conversion from Unity units to pixels.
        private readonly float scale_;

        // The map is [layer][rows][columns]. The |columns| is the count
        // of elements in the x coordinate, in other words the size of each row.
        private int[,,] map_;
        private List<RectangleF> player_spawn_;
        private List<List<PointF>> water_deep_;

        private int pixels_wide_;
        private int pixels_height_;

        // The scale is used to scale all the loaded properties
        // that use distances. Tiled uses floating point pixels.
        public MapHandler(int scale_int)
        {
            scale_ = scale_int;
        }

        public IEnumerable<RectangleF> GetPlayerSpawns()
        {
            foreach (var spawn in player_spawn_)
            {
                yield return new RectangleF(spawn.X, spawn.Y, spawn.Width, spawn.Height);
            }
        }

        public bool SendMap(int toClient)
        {
            for (int layer = 0; layer < Layers; layer++)
            {
                for (int iy = 0; iy < Row_count; iy++)
                {
                    var real_row = Row_count - iy - 1;
                    ServerSend.MapLayerRow(
                        toClient, layer, real_row, Column_count, GetRowIter(layer, iy));
                }
            }

            return true;
        }

        // Maps are JSON files generated by Tiled map editor (https://github.com/mapeditor/tiled).
        // The current good maps are in the "maps" directory for source control purposes, but the
        // maps that are actually used are expected to be in the output directory.
        public void LoadMapJSON(string path_map)
        {
            using (var reader = new System.IO.StreamReader(path_map))
            {
                var root = JsonDocument.Parse(reader.BaseStream).RootElement;
                
                if (root.GetProperty("type").GetString() != "map")
                {
                    throw new Exception($"Map error: type is a not map");
                }
                
                var column_count = root.GetProperty("width").GetInt32();
                var row_count = root.GetProperty("height").GetInt32();
                var layers = root.GetProperty("layers");
                var layer_count = layers.GetArrayLength();

                var tile_width = root.GetProperty("tilewidth").GetInt32();
                var tile_height = root.GetProperty("tileheight").GetInt32();

                pixels_wide_ = tile_width * column_count;
                pixels_height_ = tile_height * row_count;

                if (root.GetProperty("compressionlevel").GetInt32() != -1)
                {
                    // We don't support any compression.
                    throw new Exception($"Map error: unsupported compression");
                }

                // Currently we only support one tileset.
                var tilesets = root.GetProperty("tilesets");
                if (tilesets.GetArrayLength() != 1)
                {
                    throw new Exception($"Map error: too many tilesets");
                }

                var firstgid = tilesets[0].GetProperty("firstgid").GetInt32();
                if (firstgid != 1)
                {
                    // Client-side we expect 0 to mean "no title" and the first
                    // title to be 1.
                    throw new Exception($"Map error: firstgid is {firstgid}");
                }

                // Process object layers here. We flatten them, that is we don't
                // care the ordering of their layers.
                int object_layers = 0;

                player_spawn_ = new List<RectangleF>();
                water_deep_ = new List<List<PointF>>();

                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "objectgroup")
                    {
                        continue;
                    }

                    var objects = layer.GetProperty("objects");
                    foreach (var obj in objects.EnumerateArray())
                    {
                        switch (obj.GetProperty("name").GetString())
                        {
                            case "spawn player":
                                player_spawn_.Add(RectFromJson(obj));
                                break;

                            case "water deep":
                                water_deep_.Add(PolygonFromJson(obj));
                                break;

                            default:
                                break;
                        }
                    }

                    object_layers++;
                }

                layer_count -= object_layers;
                map_ = new int[layer_count, row_count, column_count];

                // Only process tile layers on this loop.
                int lyr = 0;
                foreach (var layer in layers.EnumerateArray())
                {
                    if (layer.GetProperty("type").GetString() != "tilelayer")
                    {
                        continue;
                    }

                    var data = layer.GetProperty("data");
                    int col = 0;
                    foreach (var cell in data.EnumerateArray())
                    {
                        var id = cell.GetInt16();
                        if (id == 0)
                        {
                            col++;
                            continue;
                        }

                        map_[lyr, col / row_count, col % column_count] = id;
                        col++;
                    }
                    lyr++;
                }

                Console.WriteLine($"loaded map [{path_map}] {layer_count}x{row_count}x{column_count}");
            }
        }

        private static float GetJSonFloat(JsonElement elem, ReadOnlySpan<char> name)
        {
            return (float)elem.GetProperty(name).GetDouble();
        }

        private RectangleF RectFromJson(JsonElement obj)
        {
            var point = PointFromJson(obj);
            var size = SizeFromJson(obj);
            return new RectangleF(point, size);
        }

        private List<PointF> PolygonFromJson(JsonElement obj)
        {
            var origin = PointFromJson(obj);
            var array = obj.GetProperty("polygon");
            List<PointF> poly = new List<PointF>();
            foreach(var point in array.EnumerateArray())
            {
                var rel_pt = PointFromJson(point);
                poly.Add(new PointF(rel_pt.X + origin.X, rel_pt.Y + origin.Y));
            }

            return poly;
        }

        private PointF PointFromJson(JsonElement obj)
        {
            var x = GetJSonFloat(obj, "x");
            var y = pixels_height_ - GetJSonFloat(obj, "y");
            return new PointF(x / scale_, y / scale_);
        }

        private SizeF SizeFromJson(JsonElement obj)
        {
            var w = GetJSonFloat(obj, "width");
            var h = GetJSonFloat(obj, "height");
            return new SizeF(w / scale_, h / scale_);
        }

        // So C# cannot return a reference to a row of a square array. Rather
        // than abandoning square arrays we can use a simple generator. Maybe
        // it is not as inneficient as it looks. 
        private IEnumerable<short> GetRowIter(int layer, int row)
        {
            for (var ix = 0; ix < Column_count; ix++)
            {
                yield return (short)map_[layer, row, ix];
            }
        }
    }
}
